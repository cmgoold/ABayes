![build](https://github.com/cmgoold/miniab/actions/workflows/test.yml/badge.svg)
[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)

# miniab

`miniab` is a lightweight Python package for performing Bayesian AB testing.
Computations are run using [Stan](
https://mc-stan.org
) via [`cmdstanpy`](
https://github.com/stan-dev/cmdstanpy
) and [`jinja2`](
https://github.com/pallets/jinja/
) is used
as a backend templating engine
to construct the Stan model files dynamically.

## Installation

To install, use:

```bash
python3.10 -m pip install git+ssh://git@github.com/cmgoold/miniab.git
```

Installing `miniab` will also create a local cache folder for storing
Stan model objects, which is `.miniab` in the repository root.

## Simple API

The simplest use-case is running a comparison
between two sets of approximately normally-distributed
data sets. First, let's sample some fake data, where
we have two groups with the following data generating
process:

```
y_{jj} ~ Normal(mu_{jj}, sigma_{jj})
mu_1 = 0, sigma_1 = 0.2
mu_2 = 1, sigma_1 = 1
```

That is, both groups data are normally distributed
with locations, `mu[1] = 0` and `mu[2] = 1`, and scales
`sigma[1] = 0.2` and `sigma[2] = 1`, respectively.
Thus, there is a true difference of means of `1` and
a true difference of scales of `0.8`. Here's the Python
code:

```python
import numpy as np

from miniab import MiniAb

rng = np.random.default_rng(1234)

N = 50
mu = [0, 1]
sigma = [0.2, 1]
y1 = np.random.normal(size=N, loc=mu[0], scale=sigma[0]) 
y2 = np.random.normal(size=N, loc=mu[1], scale=sigma[1]) 
```

We then initialize a `MiniAb` object with the default options
(normal likelihood, default priors) and fit the model, passing
the data in as a tuple:

```python
ab = MiniAb()
ab.fit(data=(y1, y2))
```

The model will run in Stan and return `self`.
You can access the `cmdstanpy.CmdStanMCMC` object
itself using `ab.cmdstan_mcmc`. To take a quick
look at the results, run `ab.summary`, which returns
a summary Pandas `DataFrame` straight from [`Arviz`](
https://github.com/arviz-devs/arviz
):

```
             mean     sd  hdi_3%  hdi_97%  mcse_mean  mcse_sd  ess_bulk ess_tail   r_hat
mu[0]      -0.000  0.006  -0.011    0.012      0.000    0.000    1871.0     909.0   1.00
mu[1]       1.009  0.032   0.948    1.067      0.001    0.001    1031.0     903.0   1.00
sigma[0]    0.197  0.004   0.189    0.205      0.000    0.000     922.0     766.0   1.00
sigma[1]    1.021  0.023   0.979    1.063      0.001    0.001     956.0     820.0   1.01
mu_diff    -1.010  0.033  -1.071   -0.950      0.001    0.001    1035.0     910.0   1.01
sigma_diff -0.824  0.023  -0.868   -0.784      0.001    0.001    1026.0     861.0   1.01
```

`miniab` always uses the terms `mu` and `sigma` to refer to 
vectors of group-specific means and standard deviations.
The additional variables `mu_diff` and `sigma_diff` give
the difference in posterior distributions between groups 1 and 2
(i.e. `mu[0] - mu[1]` using Python's zero-indexing).

## Under the hood 
We can in inspect the likelihood distribution and priors via `MiniAb`'s
properties:

```python
ab.likelihood, ab.priors
Out[3]: ('normal', {'mu': 'normal(0, 1)', 'sigma': 'normal(0, 1)'})
```

The priors correspond to both groups (i.e. the Stan data is assumed in
long-format and the prior statements are vectorized). Currently,
different priors for each group is not a supported feature of `MiniAb`.
By default, standard normal priors are set on the model parameters
(standard half-normal for standard deviations),
which are accessed via `miniab.miniab.DEFAULT_PRIORS`.
The prior text are just strings passed directly to Stan, so
users can subsititute with any distribution and constants they wish.

The `ab.model` attribute returns the `cmdstanpy.CmdStanModel` attribute,
which is stored in the cache location. The 'private' attribute `_render_model`
can be used, if interested, to see the raw Stan code:

```python
ab._render_model()
```

which returns:

```stan
/* Stan file generated by Conor Goold, 2023. 
 * This program is covered by an GNU license.
*/ 

data {
  /* data declarations */
  int<lower=0> N;
  array[N] int<lower=1, upper=2> j;
  vector[N] y;
}

transformed data {
  /* data transformations */
}

parameters {
  
  /* raw model parameters */
  vector[2] mu;
  vector<lower=0>[2] sigma;

}

transformed parameters {
  
  /* parameter transformations */
  // nb: no change of variables adjustments are made
  // to these parameters
  vector[N] mu_j = mu[j];
  vector<lower=0>[N] sigma_j = sigma[j];

}

model {

  
  /* priors */
  mu ~ normal(0, 1);
  sigma ~ normal(0, 1);


  /* likelihood statement */
  y ~ normal(mu_j, sigma_j);

}

generated quantities {

  
  /* declarations */
  real mu_diff;
  real sigma_diff;
  vector[N] y_rep;


  
  /* computations */
  mu_diff = mu[1] - mu[2];
  sigma_diff = sigma[1] - sigma[2];
  for(n in 1:N)
    y_rep[n] = normal_rng(mu_j[n], sigma_j[n]);

}
```

